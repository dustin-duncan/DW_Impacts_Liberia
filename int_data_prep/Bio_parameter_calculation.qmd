---
title: "Bio_parameter_calculation"
author: "Dustin Duncan"
format: html
editor: visual
---

```{r}
library(tidyverse)
library(devtools)
# install_github("https://github.com/haddonm/MQMF")
# devtools::install_github("https://github.com/haddonm/MQMF")
library(MQMF)
```

## Estimating catchability from abundance and cpue data

Catchability can be calculated different ways for species. One could use

\begin{align}
q_{ijm} = - [ln(-1\frac{area_{m}RET_{ijm}}{AREA})]
\end{align}

Where AREA is the area occupied by the stock, $RET_{ijm}$ is the gear retention of species *i* by age *j* by the gear of vessel type *m*, defined by a gear selection ogive, and $area_{m}$ is the area swept per day.

The specific gear retention by size is:

\begin{align}
RET_{ijm} = \frac{1}{1+e^{S1_{im}-S2_{im}L_{ij}}} 
\end{align}

\begin{align}
S1_{im} = L_{im50\%} ln \frac{3}{L_{im75\%}-L_{im50\%}} 
\end{align}

\begin{align}
S2_{im} = \frac{S1_{im}}{L_{im50\%}}
\end{align}

Where $L_{im50\%}$ and $L_{im75\%}$ are, respectively, the length at 50% and 75% retention by fleet type *m*.

If we have the slope and intercept of the maturity ogive, then we can use the length and slope to estimate $L_{im75\%}$ with the following formula:

\begin{align}
L_{im75\%} = L_{im50\%} + \frac{ln(1/3)}{a}
\end{align}

Where $L_{im50\%}$ = 13.99, and a = 12.204

```{r}
SR = 19.5 - 13.99 
L75 = 13.99 + 0.5*SR # Approximately 16.745

cpue = read.csv(here::here("data_int/data_FAO/cpue_timeseries_1990_2017.csv"))
effort = read.csv(here::here("data_int/data_FAO/effort_timeseries_1990_2017.csv"))
catch = read.csv(here::here("data_int/data_FAO/catch_timeseries_1990_2017.csv"))
catch_nafaa = read.csv(here::here("data_int/data_NaFAA/catch_timeseries_2018_2023.csv"))
catch_90_23 = catch %>% 
  rbind(catch_nafaa)
catch_effort = catch %>% 
  cbind(effort$Effort) %>% 
  rename(Effort = `effort$Effort`)
catch_nafaa_eff = catch_nafaa %>% 
  mutate(Effort = NA) %>% 
  rbind(catch_effort)
options(scipen=999)
5115/(158446*60000)
ggplot(cpue, aes(x = Year, y = CPUE, color = Fleet)) + 
  geom_line()
ggplot(effort, aes(x = Year, y = Effort, color = Fleet)) + 
  geom_line()
ggplot(catch, aes(x = Year, y = Catch_tonnes, color = Fleet)) + 
  geom_line()
ggplot(catch_90_23, aes(x = Year, y = Catch_tonnes, color = Fleet)) + 
  geom_point()
```

### Another method for calculating catchability 

Another method that we can use to calculate catchability is the cathc, effort, and biomass data which we have for each of the years. Maybe we can use individual years and average them, but right now we're going to just use the same catchability for either. We will use the last year of catch for industrial fisheries, and see if it works. 

Formula: 

\begin{align}
q = (C/E)/B
\end{align}

Where C is catch, E is effort, and B is biomass.

```{r}
catch_filtered = catch %>% 
  filter(Year %in% 2011)
effort_filtered = effort %>% 
  filter(Year %in% 2011)

c_e_joined = catch_filtered %>% 
  select(-c(Country)) %>% 
  inner_join(effort_filtered, by = c("Year", "Fleet")) %>% 
  select(-c(Country)) %>% 
  mutate(Biomass = 100000*0.6) %>% 
  mutate(q = ((Catch_tonnes/Effort)/Biomass))
q_ssf = c_e_joined[1, 6]
q_dwf = c_e_joined[2, 6]
options(scipen=999)
q_ssf
q_dwf

b_2010=3241/(q_ssf*139987)
effort=139/(q_dwf*b_2010)


```

Estimated that by 2017 the stock was 60,000 tonnes, so we can use this with catchability and yield from the following time-series to estimate effort for the years available in the NaFAA data? 

## Looking at whether CPUE and catch are linearly related 

```{r}
# Artisanal
cpue_s = cpue %>% 
  filter(Fleet %in% c("Artisanal")) 
catch_s = catch %>% 
  filter(Fleet %in% c("Artisanal")) 
bound_data_s = cpue_s %>% 
  full_join(catch_s, by = c("Year", "Fleet", "Country")) %>% 
  select(-c(Country)) %>% 
  filter(Year > 1997) %>% 
  mutate(Catch_tonnes = as.numeric(Catch_tonnes)) %>% 
  janitor::clean_names()

model = lm(bound_data_s$cpue ~ bound_data_s$catch_tonnes)
summary(model) # Hooray there is a correlation 

cpue_d = cpue %>% 
  filter(Fleet %in% c("Industrial")) 
catch_d = catch %>% 
  filter(Fleet %in% c("Industrial")) 
bound_data_d = cpue_d %>% 
  full_join(catch_d, by = c("Year", "Fleet", "Country")) %>% 
  select(-c( Country)) %>% 
  drop_na() %>% 
  mutate(Catch_tonnes = as.numeric(Catch_tonnes)) %>% 
  janitor::clean_names()

model2 = lm(bound_data_d$cpue ~ bound_data_d$catch_tonnes)
summary(model2) # Hooray there is a correlation (but its positive)
```

## ASPM Model from "Using R for Modelling and Quantitative Methods in Fisheries "(M. Haddon)

```{r this is the chunk that matters}
# If we have natural mortality, estimated biomass, and catch, we might be able to model the population and search for the level of fishing mortality that would lead to the catch seen. If this were the case then we could then optimize the age class numbers, and estimate the ability to predict catch from fishing mortality estimates. First we will implement the age structure, and then we will implement catch to see how it works 

# Notes from Anthony, 2019: 
# Average size of sexual maturity is 20.75cm (males) and 21.76cm (females). Suggests 50% of females are mature at 17.50cm, and 16.60cm for males.
# Juveniles are fish that are smaller than L50, mature fish are between length L50 and Lopt, and mega-spawners are defined as fish that are Lopt plus 10% in size 
# If size can be used as a proxy for age, then it would be easy to classify the years at which certain cohorts should transfer into the above cohort, and use categorical age classes rather than actual age of the fish. 
# spm() 

# This function makes sense. I would like the output to be at FIRST, just the biological projection. After, I would like it to include the interaction between both catches, with catch being determined by effort and cost per unit effort. This will allow me to calibrate the model on the 1990-2017 data, then I should be able to back out effort from the 2018-2023 data with the information this model gives me. If I can predict effort from catch and consistent CPUE data, then I should be able to estimate effort for the new data and project it going forward under different price regimes. 

# Fuck it we start by listing out the parameters we need. 
# beverton-holt growth parameters will have BH prefix 
# Length-age parameters will have LA prefix 
  # These lengths will divide the three age classes and will act to delineate the years in which one cohort graduates into another. 
# Mass-length parameters will have WL prefix

length_weight_at_age = function(maxage, Linf, K1, K2, t0, Waa, Wab, Winf) {
  
  La = vector(mode='numeric', length=0)
  wa1 = vector(mode='numeric', length=0)
  wa2 = vector(mode='numeric', length=0)
  
  ages = seq(from=0, to=maxage, by=1)
  
  for(a in ages+1) {
    La[a] = Linf*(1-exp(-K1*(ages[a]-t0)))
    wa1[a] = Waa*(La[a]^(Wab))
    wa2[a] = Winf*(1-exp(-K2*(ages[a]-t0)))^Wab
  }
  
  return(tibble("Age"=ages, "La"=La, "wa1"=wa1,"wa2"=wa2))
}

test = length_weight_at_age(maxage=9, Linf=44.46, K1= 0.38, t0=-0.387, Waa=0.02, Wab=3.00, Winf=1055, K2=0.38) %>% 
  mutate(prop_mature = case_when(
    Age == 0 ~ 0,
    Age == 1 ~ .25,
    Age == 2 ~ .35,
    Age == 3 ~ .50,
    Age == 4 ~ .75,
    Age == 5 ~ .78,
    Age == 6 ~ .80,
    Age == 7 ~ .85,
    Age == 8 ~ .90,
    Age == 9 ~ .95,
  ),
  wakg = wa2/1000)

# Biomass in year 2018 est. = 60,000 tonnes. Creating rough estimates of individuals given biomass and Anthony Yukie's paper of catch estimates
Bi = 60000
juv_B = .81*Bi # 48600 tonnes, 0-2 yr old (3 ages)
juv_ratio = juv_B/3
ym_B = .13*Bi # 7800 tonnes, 3-4 yr old (2 ages)
ym_ratio = ym_B/2
om_B = .06*Bi # 3600 tonnes, 5+ yr old (5 ages)
om_ratio = om_B/5 

test = test %>% 
  mutate(Tonnes_ratio = case_when(
    Age %in% 0:2 ~ juv_ratio,
    Age %in% 3:4 ~ ym_ratio,
    Age %in% 5:9 ~ om_ratio
  ), # 1 tonne is 1000 kg, so Tonnes_ratio*1000 = kg_ratio
  kg_ratio = Tonnes_ratio*1000,
  Na = kg_ratio/wakg
  )

spawning_biomass = sum(tibble(SB = case_when(test$Age > 2 ~ test$Na*test$wakg))$SB, na.rm = TRUE)
total_biomass = sum(tibble(TB = test$Na*test$wakg)$TB, na.rm=TRUE)

NAr[i] = (4*h*R0*Bsp[i-1])/(((1-h)*B[i])+(((5*h)-1)*Bsp[i-1]))
# $steep
# [1] 0.75
h = 0.75
# $R0
# [1] 13.7
R0 = 20
# $sela50
# [1] 14
# 
# $deltaS
# [1] 1
B_total = sum(test$wakg*test$Na)

NAr = ((4*h*R0*spawning_biomass)/(((1-h)*B_total)+(((5*h)-1)*spawning_biomass)))/test[1, 6]
time=seq(from=0, to=5, by=1)
ages=seq(from=0, to=9, by=1)


inparams1 = c("maxage"=9, "h"=1, "R0"=20, "sela50"=2.5, "deltas"=1, "Winf"=1055, "Wab"=2, "K2"=0.38, "t0"=-0.5, "M"=.81, "q"=5.38e-7, "eff" = 1.58e5, "propJ"=.70, "propY"=0.20, "propO"= 0.10, "Time"=12)

inp1 = c("SB_init"=11400000, "TB_init"=6e7)
# inp[["SB_init"]]
aspm = function(inparams=inparams1, inp=inp1, indat=NULL) {
  time = inparams[["Time"]]
  N = vector("list",length(inparams[["Time"]]))
  EB = vector("list",length(inparams[["Time"]]))
  H = vector("list",length(inparams[["Time"]]+1))
  SB = vector("list",length(inparams[["Time"]]+1))
  TB = vector("list",length(inparams[["Time"]]+1))
  Catch = vector("numeric",length(inparams[["Time"]]))
  
  # Defining age and time vectors which we will sequence over 
  # time=seq(from=1, to=time, by=1)
  ages=seq(from=0, to=inparams[["maxage"]], by=1)
  
  initial_pop = c(
    inparams[["propJ"]]*inp[["TB_init"]]/3,
    inparams[["propJ"]]*inp[["TB_init"]]/3,
    inparams[["propJ"]]*inp[["TB_init"]]/3,
    inparams[["propY"]]*inp[["TB_init"]]/2,
    inparams[["propY"]]*inp[["TB_init"]]/2,
    inparams[["propO"]]*inp[["TB_init"]]/5,
    inparams[["propO"]]*inp[["TB_init"]]/5,
    inparams[["propO"]]*inp[["TB_init"]]/5,
    inparams[["propO"]]*inp[["TB_init"]]/5,
    inparams[["propO"]]*inp[["TB_init"]]/5)
  
  s = 1/(1+exp((inparams[["sela50"]]-ages)/inparams[["deltas"]]))
  wa = (inparams[["Winf"]]*(1-exp(-inparams[["K2"]]*(ages-inparams[["t0"]])))^inparams[["Wab"]])/1000
  
  
    N[[1]] = initial_pop
  EB[[1]] = wa[age]*s[age]*N[[1]]
  H[[1]] = inparams[["eff"]]*inparams[["q"]]*EB[[1]]
  SB[[1]]=inp[["SB_init"]]
  TB[[1]]=inp[["TB_init"]]
  
  for(t in 2:time){
  N[[t]] <- numeric(length(ages))
  EB[[t]] <- numeric(length(ages))
  H[[t]] <- numeric(length(ages))
  
  s = 1/(1+exp((inparams[["sela50"]]-ages)/inparams[["deltas"]]))
  wa = (inparams[["Winf"]]*(1-exp(-inparams[["K2"]]*(ages-inparams[["t0"]])))^inparams[["Wab"]])/1000
    
    for(a in 2:(ages-1)){
      
      if(a == 1 ) {
       N[[t]][a]=((4*inparams[["h"]]*inparams[["R0"]]*SB[[t-1]])/(((1-inparams[["h"]])*inp[["TB_init"]]) + ((5*inparams[["h"]] - 1)*SB[[t-1]])))/wa[a] # Having issues here. Why is it essentially one? 
      } 
       
        N[[t]][a+1] = N[[t-1]][a]*exp(-inparams[["M"]]/2)
      
      EB[[t]][a+1] = wa[a+1]*s[a+1]*N[[t]][a+1]
      
      # H[[t+0.5]] = C[[t+0.5]]/EB[[t+0.5]][age]
      H[[t]][a+1] = inparams[["eff"]]*inparams[["q"]]*EB[[t]][a+1]
      
      N[[t]][a+1] = N[[t]][a+1]*(1-(s[a+1]*H[[t]][a+1]))*exp(-inparams[["M"]]/2) 
      
      
      SB[[t]]=sum(N[[t]][3:10]*wa[3:10])
      
      TB[[t]]=sum(N[[t]][1:10]*wa[1:10])
      # Catch[t]=sum(H[[t]][])
    }
  Catch[t]=sum(H[[t]][1:10])
  }
  # list("Time"=time, "Total Biomass"=TB, "Catch" = H, "Age"=ages, "N"=N, "EB"=EB)
  # Catch = sum(Catch)
  return(Catch)
}

test_fx = aspm()
catch_nafaa$Year = seq(from=1,to=inparams1[["Time"]], by=1)
MQMF::negLL(pars=log(inp1), funk=aspm, logobs=log((catch_nafaa$Catch_tonnes*1000)), indat=catch_nafaa, inparams=inparams1)

# Need method of estimating parameter sets that minimize the sum of squared difference between the predicted and observed values 

# first lets just drop the spm function in here 
cpue_vec = cpue %>% 
  filter(Year %in% 2008:2017) %>% 
  select(-c(Country,)) %>% 
  group_by(Year) %>% 
  summarise(CPUE = sum(CPUE, na.rm = TRUE)) %>% 
  ungroup()
dat = catch_90_23 %>% 
  filter(Year %in% 2008:2017) %>% 
  group_by(Year) %>% 
  summarise(Catch_tonnes = sum(Catch_tonnes, na.rm=TRUE)) %>% 
  left_join(cpue_vec, by = "Year") %>% 
  rename(Catch = Catch_tonnes) %>% 
  janitor::clean_names() %>% 
  mutate(cpue = cpue+0.01) %>% 
  ungroup()


pars=log(c(r=0.5, K=100000, Binit=60000, sigma=0.2))
dat_fx = as.matrix(dat)
ans=plotspmmod(pars,dat_fx)
bestSP <- fitSPM(pars=pars, fish=dat_fx, maxiter=1e3, funk = simpspm)
outfit(bestSP)
ans <- plotspmmod(bestSP$estimate,dat_fx,schaefer=TRUE)
ans$Dynamics$parameters

function (pars, funk, logobs, ...) 
{
  npar <- length(pars)
  logpred <- funk(pars, ...)
  pick <- which(is.na(logobs))
  if (length(pick) > 0) {
    LL <- -sum(dnorm(x = logobs[-pick], mean = logpred[-pick], 
      sd = exp(pars[npar]), log = TRUE))
  }
  else {
    LL <- -sum(dnorm(x = logobs, mean = logpred, sd = exp(pars[npar]), 
      log = TRUE))
  }
  return(LL)
}

```


```{r}
aspm = function(inparams, incond, time) {
  # Define ages first
  ages = 0:inparams[["maxage"]]
  
  # Initialize lists and vectors correctly
  N = vector("list", time)
  EB = vector("list", time)
  H = vector("list", time)
  SB = numeric(time)
  TB = numeric(time)
  
  # Calculate s and wa outside the loop
  s = 1 / (1 + exp((ages - inparams[["sela50"]]) / inparams[["deltas"]]))
  wa = (inparams[["Winf"]] * (1 - exp(-inparams[["K2"]] * (ages - inparams[["t0"]])))^inparams[["Wab"]]) / 1000
  
  # Initial conditions
  initial_pop = c(
    .81 * incond[["TB_init"]] / 3,
    .81 * incond[["TB_init"]] / 3,
    .81 * incond[["TB_init"]] / 3,
    .13 * incond[["TB_init"]] / 2,
    .13 * incond[["TB_init"]] / 2,
    rep(.06 * incond[["TB_init"]] / 5, 5)
  )
  
  N[[1]] = initial_pop
  EB[[1]] = wa * s * N[[1]]
  H[[1]] = inparams[["eff"]] * inparams[["q"]] * EB[[1]]
  SB[1] = sum(N[[1]][3:10] * wa[3:10])  # Assuming ages 2-9 correspond to indices 3-10
  TB[1] = incond[["TB_init"]]
  
  for(t in 2:time) {
    N[[t]] = numeric(length(ages))
    EB[[t]] = numeric(length(ages))
    H[[t]] = numeric(length(ages))
    N[[t]][1] = ((4 * inparams[["h"]] * SB[t]) / 
                 (((1 - inparams[["h"]]) * TB[t]) + 
                    ((5 * inparams[["h"]] - 1) * SB[t]))) / wa[1]
    for(a in 1:(length(ages)-1)) {
      if(a == 1 ) {
        N[[t]][a] = ((4 * inparams[["h"]] * inparams[["R0"]]*SB[t-1]) / 
                 (((1 - inparams[["h"]]) * TB[t-1]) + 
                    ((5 * inparams[["h"]] - 1) * SB[t-1]))) / wa[a]
      } else {
        N[[t]][a+1] = N[[t-1]][a] * exp(-inparams[["M"]] / 2)
      EB[[t]][a+1] = wa[a+1] * s[a+1] * N[[t]][a+1]
      H[[t]][a+1] = inparams[["eff"]] * inparams[["q"]] * EB[[t]][a+1]
      N[[t]][a+1] = N[[t]][a+1] * (1 - (s[a+1] * H[[t]][a+1])) * exp(-inparams[["M"]] / 2)
      }
      
    }
    
    SB[t] = sum(N[[t]][3:10] * wa[3:10])  # Assuming ages 2-9 correspond to indices 3-10
    TB[t] = sum(N[[t]] * wa)
  }
  
  return(list("Time" = 1:time, "Total Biomass" = TB, "Catch" = H, "Age" = ages, "N" = N))
}

test_fx = aspm(inparams = inparams, incond = incond, time=10)

```

Parameters needed: 

**Length-at-age**

- `Linf` = $L_{\infty}$, asymptotic average maximum length 
- `K` = $k$, the growth rate coefficient 
- `t0` = $t_{0}$, the theoretical length at age zero
- `a` = age $a$
- `La` = $L_{a}$ length at age a

`La=Linf*(1-exp(-K*(a-t0)))`

Formula: 

$$
L_{a}=L_{\infty}(1-e^{-k(a-t_{0})})
$$

**Mass-at-age**

- `Waa`, `Wab` = $W_{aa} = 0.02, W_{ab} = 3$ coefficients that define the power relationship between length and mass 
- `wa` = the mass at age $a$
- `La` = $L$ the length 


`wa = Waa*(La^(Wab))`

Formula:

$$
w_{a}=W_{aa}L^{W_{ab}}
$$

**Global Parameters**

- Population ages: `maxage`, `ages` 
- Natural Mortality: `M`
- Age at 50% maturity: `M50a`
  - delta: `deltaM`
- Steepness of the stock recruitment relationship: `h`

**Initiating age-structured model**

- `NAr` = Recruits; not fished but important to include? They contribute to next cohort
- `R0` = constant unfished recruitment level (may include an exp(-M) term but not certain yet)
- `h` = Beverton-holt steepness (used to calculate the a and b terms)
- `Bsp` = $B^{sp}_{y}$ is the spawning biomass (in year i) 
- `B` = $B_{y}$ is the biomass in year i

`NAr[i] = (4*h*R0*Bsp[i-1])/(((1-h)*B[i])+(((5*h)-1)*Bsp[i-1]))`

$$
N_{0,y} = \frac{4hR_{0}B^{sp}_{y-1}}{(1-h)B_{0}+(5h-1)B^{sp}_{y-1}}
$$
**Stock dynamics**

Selectivity: 

- `sa` = Selectivity associated with fishing gear for age a
- `a` = age $a$
- `sela50` =  $a_{50}$ Age at 50% selectivity
  - `deltaS` = $\delta$

`sa = 1/(1 + exp((a-sela50)/deltaS))`

$$
s_{a} = \frac{1}{(1 + e^{(\frac{a-a_{50}}{\delta})})}
$$
Spawning Biomass for year y:

- `Bsp` = $B^{sp}_{y}$ is the spawning biomass (in year i)
- `wa` = the mass at age $a$ in year y 
- `ma` = the proportion mature at age a in year y 
- `Na` = the number of age a in year y

##### NEED FORMULA ######

$$
B_{y}^{sp}= \sum_{a=0}^{a_{x}}w_{a}m_{a}N_{a,y}
$$
- Na = 
- NAj = Juveniles; The number of individuals below L50 each year: ages 0-2
- NAy = Young mature; The number of individuals between L50 and Lopt each year: ages 2-3
- NAm = Superspawners; The number of individuals above Lopt each year: ages 3-9

First; we need to identify the ages that correspond to different length parameters. 

## Calculating ages based off of different lengths to set global parameters:

```{r}
age_est = function(Linf, La, K, t0) {
  
  a = (log(1-(La/Linf))/-K)+t0
  
  return(a)
}
age_plot = function(Linf, max_age, K, t0) {
  
  La = vector(mode = "numeric", length = 0)
  ages = seq(from = 1, to = round(max_age), by=1)
  
  for(i in ages){
    La[i] = Linf*(1-exp(-K*(ages[i]-t0)))
  }
  return(La)
}

# Length estimates for round sardinella; 
# Linf = 35.42
# La at 50% maturity = 21.25 
# La at Lopt = 26.15

juvenile_age_upper = age_est(35.42, 21.25, 0.38, -0.5) # 0-2 age is juvenile

young_age_upper = age_est(35.42, 26.15, 0.38, -0.5) # 2-3yrs

max_age = age_est(44.46, 35.41, 0.38, -0.5) # 3-9 years

test = tibble(Length = age_plot(44.63, 20, 0.38, -0.387), age = seq(from=1, to=20, by=1))

ggplot(test, aes(x = age, y = Length)) +
  geom_line()
```











